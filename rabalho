#include <stdio.h>
#include <stdlib.h>
#include <time.h>

#define TAMANHO_FILA 5

typedef struct {
    char nome;
    int id
} Peca;

Peca fila[TAMANHO_FILA];
int frente = -1;
int tras = -1;
int contador_pecas = 0;
int proximo_id = 0;
/
int estaVazia() {
    return (contador_pecas == 0);
}

int estaCheia() {
    return (contador_pecas == TAMANHO_FILA);
}
Peca gerarPeca() {
    Peca novaPeca;
    char tipos[] = {'I', 'O', 'T', 'L'};
    int num_tipos = sizeof(tipos) / sizeof(tipos[0]);

    novaPeca.nome = tipos[rand() % num_tipos]; 
    
    novaPeca.id = proximo_id++;
    
    return novaPeca;
}

void inicializarFila() {

    proximo_id = 0; 
    frente = -1;
    tras = -1;
    contador_pecas = 0;

    printf("üîß Inicializando a fila de pe√ßas com %d elementos...\n", TAMANHO_FILA);

    for (int i = 0; i < TAMANHO_FILA; i++) {
        Peca p = gerarPeca();
       
        if (estaVazia()) {
            frente = 0;
            tras = 0;
        } else {
            tras = (tras + 1) % TAMANHO_FILA;
        }
        fila[tras] = p;
        contador_pecas++;
    }
}

void inserirPeca(Peca p) {
    if (estaCheia()) {
        printf("\n‚ùå ERRO: A fila est√° cheia. N√£o foi poss√≠vel inserir a pe√ßa %c %d.\n", p.nome, p.id);
        return;
    }
    
    if (estaVazia()) {
        frente = 0;
        tras = 0;
    } else {
        tras = (tras + 1) % TAMANHO_FILA;
    }

    fila[tras] = p;
    contador_pecas

    #include <stdio.h>
#include <stdlib.h>
#include <time.h>


#define TAMANHO_FILA
#define CAPACIDADE_PILHA

typedef struct {
    char nome;
    int id;
} Peca;

Peca fila[TAMANHO_FILA];
int frente = -1;
int tras = -1;
/

Peca pilha[CAPACIDADE_PILHA];
int topo = -1;
int proximo_id = 0;

int filaEstaCheia() {
  
    return (proximo_id >= TAMANHO_FILA);
}

int pilhaEstaVazia() {
    return (topo == -1);
}

int pilhaEstaCheia() {
    return (topo == CAPACIDADE_PILHA - 1);
}

Peca gerarPeca() {
    Peca novaPeca;
    char tipos[] = {'I', 'O', 'T', 'L'};
    int num_tipos = sizeof(tipos) / sizeof(tipos[0]);

    novaPeca.nome = tipos[rand() % num_tipos]; 
    
    novaPeca.id = proximo_id++;
    
    return novaPeca;
}
/
void inicializarFila() {
    printf("üîß Inicializando a fila de pe√ßas (%d elementos)...\n", TAMANHO_FILA);

    for (int i = 0; i < TAMANHO_FILA; i++) {
        Peca p = gerarPeca();
        
        if (frente == -1) {
            frente = 0;
            tras = 0;
        } else {
            tras = (tras + 1) % TAMANHO_FILA;
        }
        fila[tras] = p;
    }
}

void enqueue(Peca p) {
    
    tras = frente; 
    fila[tras] = p;


    printf("   -> REABASTECIMENTO: Nova pe√ßa [%c %d] inserida no final da fila (√≠ndice %d).\n", p.nome, p.id, tras);
}

void jogarPeca() {

    Peca pecaRemovida = fila[frente];
    
    printf("\nüé≤ A√ß√£o 1: JOGAR PE√áA.\n");
    printf("   -> USO: Pe√ßa [%c %d] removida da frente da Fila (dequeue).\n", pecaRemovida.nome, pecaRemovida.id);

    frente = (frente + 1) % TAMANHO_FILA;

    Peca novaPeca = gerarPeca(); 
    enqueue(novaPeca); 
}

void reservarPeca() {
    printf("\nüì¶ A√ß√£o 2: RESERVAR PE√áA.\n");

    if (pilhaEstaCheia()) {
        printf("   ‚ùå ERRO: A Pilha de Reserva est√° cheia (%d/%d). N√£o foi poss√≠vel reservar.\n", CAPACIDADE_PILHA, CAPACIDADE_PILHA);
        return;
    }

    Peca pecaReservada = fila[frente];
    
    topo++;
    pilha[topo] = pecaReservada;
    printf("   -> TRANSFER√äNCIA: Pe√ßa [%c %d] movida da Fila para a Pilha de Reserva (Push).\n", pecaReservada.nome, pecaReservada.id);

    frente = (frente + 1) % TAMANHO_FILA;

    Peca novaPeca = gerarPeca(); 
    enqueue(novaPeca);
}


void usarPecaReservada() {
    printf("\nüåü A√ß√£o 3: USAR PE√áA RESERVADA.\n");

    if (pilhaEstaVazia()) {
        printf("   ‚ùå ERRO: A Pilha de Reserva est√° vazia. Nenhuma pe√ßa para usar (Pop).\n");
        return;
    }

    Peca pecaUsada = pilha[topo];
    
    topo--;
    printf("   -> USO: Pe√ßa [%c %d] removida do Topo da Pilha de Reserva (Pop).\n", pecaUsada.nome, pecaUsada.id);

    Peca novaPeca = gerarPeca(); 
    enqueue(novaPeca);
}

void exibirEstado() {
    printf("\n======================================================\n");
    printf("üìä ESTADO ATUAL:\n");

    printf("Fila de pe√ßas (%d/%d): ", TAMANHO_FILA, TAMANHO_FILA);

    for (int i = 0; i < TAMANHO_FILA; i++) {
        int indice_atual = (frente + i) % TAMANHO_FILA;
        printf("[%c %d]", fila[indice_atual].nome, fila[indice_atual].id);
        if (i < TAMANHO_FILA - 1) {
            printf(" ");
        }
    }
    printf("\n");
    printf("    Pr√≥xima a sair (Frente): [%c %d]\n", fila[frente].nome, fila[frente].id);
    
    printf("Pilha de reserva (Topo -> Base) (%d/%d): ", topo + 1, CAPACIDADE_PILHA);

    if (pilhaEstaVazia()) {
        printf("[VAZIA]\n");
    } else {
        
        for (int i = topo; i >= 0; i--) {
            printf("[%c %d]", pilha[i].nome, pilha[i].id);
            if (i > 0) {
                printf(" ");
            }
        }
        printf("\n");
        printf("    Pr√≥xima a sair (Topo): [%c %d]\n", pilha[topo].nome, pilha[topo].id);
    }
    printf("======================================================\n");
}

void exibirMenu() {
    printf("\n--- Op√ß√µes de A√ß√£o ---\n");
    printf("C√≥digo | A√ß√£o\n");
    printf("1      | Jogar pe√ßa (dequeue da Fila)\n");
    printf("2      | Reservar pe√ßa (Fila -> Pilha)\n");
    printf("3      | Usar pe√ßa reservada (pop da Pilha)\n");
    printf("0      | Sair\n");
    printf("------------------------\n");
    printf("Digite o c√≥digo da a√ß√£o: ");
}

int main() {
    int opcao;
    
    srand(time(NULL));

    inicializarFila();


    exibirEstado();

    do {
        exibirMenu();
      
        if (scanf("%d", &opcao) != 1) {
            while (getchar() != '\n'); 
            opcao = -1;
            printf("\nOp√ß√£o inv√°lida. Tente novamente.\n");
            continue;
        }

        switch (opcao) {
            case 1:
                jogarPeca();
                exibirEstado();
                break;
            case 2
                reservarPeca();
                exibirEstado();
                break;
            case 3:
                usarPecaReservada();
                exibirEstado();
                break;
            case 0:
                printf("\nüëã Saindo do programa. Obrigado!\n");
                break;
            default:
                printf("\nOp√ß√£o inv√°lida. Tente novamente.\n");
                break;
        }

    } while (opcao != 0);

    return 0;
}

#include <stdio.h>
#include <stdlib.h>
#include <time.h>

#define TAMANHO_FILA
#define CAPACIDADE_PILHA 

typedef struct {
    char nome;
    
    int id;
    
} Peca;

Peca fila[TAMANHO_FILA];
int frente = -1;
Peca pilha[CAPACIDADE_PILHA];
int topo = -1;

int proximo_id = 0; 


int pilhaEstaVazia() {
    return (topo == -1);
}

int pilhaEstaCheia() {
    return (topo == CAPACIDADE_PILHA - 1);
}

Peca gerarPeca() {
    Peca novaPeca;
    char tipos[] = {'I', 'O', 'T', 'L'}; 
    int num_tipos = sizeof(tipos) / sizeof(tipos[0]);
    
    novaPeca.nome = tipos[rand() % num_tipos]; 
    novaPeca.id = proximo_id++;
    
    return novaPeca;
}

void enqueue(Peca p, int indice_liberado) {

    fila[indice_liberado] = p;
    printf("   -> REABASTECIMENTO: Nova pe√ßa [%c %d] inserida no final da fila (√≠ndice %d).\n", p.nome, p.id, indice_liberado);
}

/
void inicializarFila() {
    int tras = -1;
    printf("üîß Inicializando a fila de pe√ßas (%d elementos)...\n", TAMANHO_FILA);

    for (int i = 0; i < TAMANHO_FILA; i++) {
        Peca p = gerarPeca();
        
        if (frente == -1) {
            frente = 0;
            tras = 0;
        } else {
            tras = (tras + 1) % TAMANHO_FILA;
        }
        fila[tras] = p;
    }
}
/
void jogarPeca() {
    Peca pecaRemovida = fila[frente];
    int indice_liberado = frente;
    
    printf("\nüé≤ A√ß√£o 1: JOGAR PE√áA.\n");
    printf("   -> USO: Pe√ßa [%c %d]
